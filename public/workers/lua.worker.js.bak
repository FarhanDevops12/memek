/* eslint-disable no-undef */
// ===== HAKUTAKA WORKER ENGINE (FENGARI EDITION - CLASSIC WORKER) =====

// 1. Load Fengari Library (LOCAL)
// Menggunakan path absolut dari root domain
try {
    importScripts('/lib/fengari-web.js'); 
} catch (e) {
    console.error("Fengari Load Error:", e);
    self.postMessage({ type: 'ERROR', msg: 'Failed to load Lua Engine (Local File Missing)' });
}

// 2. Ensure Fengari is loaded globally
const fengari = self.fengari || window.fengari;
// ... sisa kode ke bawah SAMA PERSIS, tidak usah diubah ...

// 2. Ensure Fengari is loaded globally
const fengari = self.fengari || window.fengari;

if (!fengari) {
    throw new Error("Fengari library not found. Worker halted.");
}

const { lua, lauxlib, lualib, to_luastring, to_jsstring } = fengari;

// --- Virtual File System ---
class VirtualFS {
    constructor() {
        this.files = new Map();
    }
    mount(bundle) {
        this.files.clear();
        for (const file of bundle) {
            let cleanPath = file.path.replace(/\\/g, '/'); // Normalize Windows paths
            if (cleanPath.startsWith('./')) cleanPath = cleanPath.substring(2);
            this.files.set(cleanPath, file.content);
        }
    }
    exists(path) { return this.files.has(path); }
    read(path) { return this.files.get(path); }
}

// --- Lua Engine Wrapper ---
class Engine {
    constructor() {
        this.L = null;
        this.fs = new VirtualFS();
    }

    initialize(bundle) {
        this.fs.mount(bundle);

        // Reset State if exists
        if (this.L) {
            lua.lua_close(this.L);
        }

        // Initialize Lua State
        this.L = lauxlib.luaL_newstate();
        lualib.luaL_openlibs(this.L);

        // 1. Compatibility Shim (Lua 5.3 -> Lua 5.1/JIT Style)
        const polyfills = `
            _G.unpack = table.unpack or _G.unpack
            _G.loadstring = load
            -- Simple bit32 shim if missing
            if not _G.bit32 then
                _G.bit32 = {}
                _G.bit32.band = function(a,b) return a & b end
                _G.bit32.bor = function(a,b) return a | b end
                _G.bit32.bxor = function(a,b) return a ~ b end
                _G.bit32.lshift = function(a,b) return a << b end
                _G.bit32.rshift = function(a,b) return a >> b end
            end
        `;
        lauxlib.luaL_dostring(this.L, to_luastring(polyfills));

        // 2. Custom Package Searcher (Bridges Lua `require` to VirtualFS)
        const loaderCode = `
            local js_fs = ...
            local function loader(name)
                local path = name:gsub("%.", "/") .. ".lua"
                if js_fs:exists(path) then
                    return load(js_fs:read(path), path)
                end
                return "\\n\\t[VFS] no file '" .. path .. "'"
            end
            table.insert(package.searchers, 2, loader)
        `;
        
        // Load chunk
        if (lauxlib.luaL_loadbuffer(this.L, to_luastring(loaderCode), null, to_luastring("vfs_loader")) !== lua.LUA_OK) {
             const err = lua.lua_tojsstring(this.L, -1);
             console.error("VFS Loader Error:", err);
             return;
        }

        // Push FS object (lightuserdata)
        lua.lua_pushlightuserdata(this.L, this.fs);
        
        // Run loader setup
        if (lua.lua_pcall(this.L, 1, 0, 0) !== lua.LUA_OK) {
            const err = lua.lua_tojsstring(this.L, -1);
            console.error("VFS Init Error:", err);
        }
    }

    run(code, preset) {
        if (!this.L) throw new Error("Engine not initialized");

        const script = `
            local code, preset = ...
            
            -- Setup Path
            package.path = "./?.lua;./src/?.lua;./src/prometheus/?.lua;" .. package.path
            
            -- Load Prometheus
            local status, P = pcall(require, "src.prometheus")
            if not status then 
                error("Failed to load Prometheus: " .. tostring(P)) 
            end
            
            local cfg = P.Presets[preset]
            if not cfg then error("Invalid Preset: " .. tostring(preset)) end
            
            cfg.PrettyPrint = false
            
            -- Execute Pipeline
            return P.Pipeline:fromConfig(cfg):apply(code, "script.lua")
        `;

        // Load Script
        if (lauxlib.luaL_loadstring(this.L, to_luastring(script)) !== lua.LUA_OK) {
            const errMsg = lua.lua_tojsstring(this.L, -1);
            lua.lua_pop(this.L, 1);
            throw new Error(`Lua Syntax Error: ${errMsg}`);
        }

        // Push Arguments
        lua.lua_pushstring(this.L, to_luastring(code));
        lua.lua_pushstring(this.L, to_luastring(preset));

        // Call (2 args, 1 result)
        const pcallStatus = lua.lua_pcall(this.L, 2, 1, 0);
        
        if (pcallStatus !== lua.LUA_OK) {
            const err = lua.lua_tojsstring(this.L, -1);
            lua.lua_pop(this.L, 1);
            throw new Error(err); // Throw pure string error from Lua
        }

        // Get Result
        const result = lua.lua_tojsstring(this.L, -1);
        lua.lua_pop(this.L, 1);
        return result;
    }
}

// --- Event Listener ---
const engine = new Engine();

self.onmessage = async (e) => {
    const { type, payload } = e.data;

    try {
        if (type === 'INIT') {
            // Fetch bundle
            const response = await fetch(`${payload.baseUrl}/prometheus-bundle.json`);
            if (!response.ok) throw new Error(`Failed to load bundle (HTTP ${response.status})`);
            
            const bundle = await response.json();
            engine.initialize(bundle);
            
            self.postMessage({ type: 'READY' });
        } 
        else if (type === 'RUN') {
            const result = engine.run(payload.code, payload.preset);
            self.postMessage({ type: 'SUCCESS', result });
        }
    } catch (err) {
        self.postMessage({ type: 'ERROR', msg: err.message || "Unknown Worker Error" });
    }
};